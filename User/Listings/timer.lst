C51 COMPILER V9.54   TIMER                                                                 07/13/2021 16:39:39 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN ..\Obj\timer.obj
COMPILER INVOKED BY: D:\Program Files\Keil\Keil_v5\C51\BIN\C51.EXE ..\Sys\timer.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Har
                    -dware;..\Peripheral;..\Sys;..\User) DEBUG OBJECTEXTEND PRINT(.\Listings\timer.lst) OBJECT(..\Obj\timer.obj)

line level    source

   1          
   2          /*------------------------------------------------------------------*/
   3          /* --- STC MCU International Limited -------------------------------*/
   4          /* --- STC 1T Series MCU RC Demo -----------------------------------*/
   5          /* --- Mobile: (86)13922805190 -------------------------------------*/
   6          /* --- Fax: 86-0513-55012956,55012947,55012969 ---------------------*/
   7          /* --- Tel: 86-0513-55012928,55012929,55012966 ---------------------*/
   8          /* --- Web: www.GXWMCU.com -----------------------------------------*/
   9          /* --- QQ:  800003751 ----------------------------------------------*/
  10          /* If you want to use the program or the program referenced in the  */
  11          /* article, please specify in which data and procedures from STC    */
  12          /*------------------------------------------------------------------*/
  13          
  14          /*************  ¹¦ÄÜËµÃ÷        **************
  15          
  16          ±¾ÎÄ¼þÎªSTC15xxxÏµÁÐµÄ¶¨Ê±Æ÷³õÊ¼»¯ºÍÖÐ¶Ï³ÌÐò,ÓÃ»§¿ÉÒÔÔÚÕâ¸öÎÄ¼þÖÐÐÞ¸Ä×Ô¼ºÐèÒªµÄÖÐ¶Ï³ÌÐò.
  17          
  18          
  19          ******************************************/
  20          
  21          
  22          
  23          #include        "timer.h"
  24          #include        "SPI.h"
  25          #include        "USART.h"
  26          
  27          u8 i;
  28          /********************* Timer0ÖÐ¶Ïº¯Êý************************/
  29          void timer0_int (void) interrupt TIMER0_VECTOR
  30          {
  31   1      //    P30 = ~P30;
  32   1      }
  33          
  34          /********************* Timer1ÖÐ¶Ïº¯Êý************************/
  35          void timer1_int (void) interrupt TIMER1_VECTOR
  36          {
  37   1      //    P31 = ~P31;
  38   1      
  39   1      }
  40          
  41          /********************* Timer2ÖÐ¶Ïº¯Êý************************/
  42          void timer2_int (void) interrupt TIMER2_VECTOR
  43          {
  44   1              // P32 = ~P32;
  45   1      }
  46          
  47          /********************* Timer3ÖÐ¶Ïº¯Êý************************/
  48          void timer3_int (void) interrupt TIMER3_VECTOR
  49          {
  50   1              // P33 = ~P33;
  51   1              static unsigned int cnt;
  52   1              if(++cnt==51)
  53   1              {
  54   2                      cnt=0;
C51 COMPILER V9.54   TIMER                                                                 07/13/2021 16:39:39 PAGE 2   

  55   2                      P34 = ~P34;
  56   2                      SPI_WriteToTxBuf((u8)0xa0);
  57   2                      SPI_WriteToTxBuf((u8)0x00);
  58   2                      SPI_WriteToTxBuf((u8)0x00);
  59   2                      SPI_TrigTx();
  60   2              }
  61   1      }
  62          
  63          /********************* Timer4ÖÐ¶Ïº¯Êý************************/
  64          void timer4_int (void) interrupt TIMER4_VECTOR
  65          {
  66   1              static unsigned int cnt;
  67   1              if(++cnt==101)
  68   1              {
  69   2                      cnt=0;
  70   2                      P34 = ~P34;
  71   2      
  72   2                      PrintString(USART1,&SPI_RxBuffer[0]);
  73   2                      // PrintString(USART1,&SPI_RxBuffer[1]);
  74   2                      // PrintString(USART1,&SPI_RxBuffer[2]);
  75   2                      PrintString(USART1,"\r");
  76   2                      // PrintString(USART1,"Hello World!\r");
  77   2                      *SPI_RxBuffer=0;
  78   2              }
  79   1      }
  80          
  81          
  82          //========================================================================
  83          // º¯Êý: u8     Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
  84          // ÃèÊö: ¶¨Ê±Æ÷³õÊ¼»¯³ÌÐò.
  85          // ²ÎÊý: TIMx: ½á¹¹²ÎÊý,Çë²Î¿¼timer.hÀïµÄ¶¨Òå.
  86          // ·µ»Ø: ³É¹¦·µ»Ø0, ¿Õ²Ù×÷·µ»Ø1,´íÎó·µ»Ø2.
  87          // °æ±¾: V1.0, 2012-10-22
  88          //========================================================================
  89          u8      Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
  90          {
  91   1              if(TIM > Timer4)        return 1;       //¿Õ²Ù×÷
  92   1      
  93   1              if(TIM == Timer0)
  94   1              {
  95   2                      if(TIMx->TIM_Mode >  TIM_16BitAutoReloadNoMask) return 2;       //´íÎó
  96   2                      TR0 = 0;                //Í£Ö¹¼ÆÊý
  97   2                      ET0 = 0;        //½ûÖ¹ÖÐ¶Ï
  98   2                      PT0 = 0;        //µÍÓÅÏÈ¼¶ÖÐ¶Ï
  99   2                      TMOD &= 0xf0;   //¶¨Ê±Ä£Ê½, 16Î»×Ô¶¯ÖØ×°
 100   2                      AUXR &= ~0x80;  //12TÄ£Ê½, 
 101   2                      INT_CLKO &= ~0x01;      //²»Êä³öÊ±ÖÓ
 102   2                      if(TIMx->TIM_Interrupt == ENABLE)               ET0 = 1;        //ÔÊÐíÖÐ¶Ï
 103   2                      if(TIMx->TIM_Polity == PolityHigh)              PT0 = 1;        //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 104   2                      TMOD |= TIMx->TIM_Mode; //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯ÖØ×°, 3: 16Î»×Ô¶¯ÖØ×°, ²
             -»¿ÉÆÁ±ÎÖÐ¶Ï
 105   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)         AUXR |=  0x80;  //1T
 106   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)        TMOD |=  0x04;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 107   2                      if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x01;      //Êä³öÊ±ÖÓ
 108   2                      
 109   2                      TH0 = (u8)(TIMx->TIM_Value >> 8);
 110   2                      TL0 = (u8)TIMx->TIM_Value;
 111   2                      if(TIMx->TIM_Run == ENABLE)     TR0 = 1;        //¿ªÊ¼ÔËÐÐ
 112   2                      return  0;              //³É¹¦
 113   2              }
 114   1      
 115   1              if(TIM == Timer1)
C51 COMPILER V9.54   TIMER                                                                 07/13/2021 16:39:39 PAGE 3   

 116   1              {
 117   2                      if(TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask) return 2;       //´íÎó
 118   2                      TR1 = 0;        //Í£Ö¹¼ÆÊý
 119   2                      ET1 = 0;        //½ûÖ¹ÖÐ¶Ï
 120   2                      PT1 = 0;        //µÍÓÅÏÈ¼¶ÖÐ¶Ï
 121   2                      TMOD &=  0x0f;  //¶¨Ê±Ä£Ê½, 16Î»×Ô¶¯ÖØ×°
 122   2                      AUXR &= ~0x40;  //12TÄ£Ê½, 
 123   2                      INT_CLKO &= ~0x02;      //²»Êä³öÊ±ÖÓ
 124   2                      if(TIMx->TIM_Interrupt == ENABLE)               ET1 = 1;        //ÔÊÐíÖÐ¶Ï
 125   2                      if(TIMx->TIM_Polity == PolityHigh)              PT1 = 1;        //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 126   2                      TMOD |= (TIMx->TIM_Mode << 4);  //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯ÖØ×°
 127   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)         AUXR |=  0x40;  //1T
 128   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)        TMOD |=  0x40;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 129   2                      if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x02;      //Êä³öÊ±ÖÓ
 130   2                      
 131   2                      TH1 = (u8)(TIMx->TIM_Value >> 8);
 132   2                      TL1 = (u8)TIMx->TIM_Value;
 133   2                      if(TIMx->TIM_Run == ENABLE)     TR1 = 1;        //¿ªÊ¼ÔËÐÐ
 134   2                      return  0;              //³É¹¦
 135   2              }
 136   1      
 137   1              if(TIM == Timer2)               //Timer2,¹Ì¶¨Îª16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÎÞÓÅÏÈ¼¶
 138   1              {
 139   2                      if(TIMx->TIM_ClkSource >  TIM_CLOCK_Ext)        return 2;
 140   2                      AUXR &= ~0x1c;          //Í£Ö¹¼ÆÊý, ¶¨Ê±Ä£Ê½, 12TÄ£Ê½
 141   2                      IE2  &= ~(1<<2);        //½ûÖ¹ÖÐ¶Ï
 142   2                      INT_CLKO &= ~0x04;      //²»Êä³öÊ±ÖÓ
 143   2                      if(TIMx->TIM_Interrupt == ENABLE)                       IE2  |=  (1<<2);        //ÔÊÐíÖÐ¶Ï
 144   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)         AUXR |=  (1<<2);        //1T
 145   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)        AUXR |=  (1<<3);        //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 146   2                      if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x04;      //Êä³öÊ±ÖÓ
 147   2      
 148   2                      TH2 = (u8)(TIMx->TIM_Value >> 8);
 149   2                      TL2 = (u8)TIMx->TIM_Value;
 150   2                      if(TIMx->TIM_Run == ENABLE)     AUXR |=  (1<<4);        //¿ªÊ¼ÔËÐÐ
 151   2                      return  0;              //³É¹¦
 152   2              }
 153   1      
 154   1              if(TIM == Timer3)               //Timer3,¹Ì¶¨Îª16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÎÞÓÅÏÈ¼¶
 155   1              {
 156   2                      if(TIMx->TIM_ClkSource >  TIM_CLOCK_Ext)        return 2;
 157   2                      T4T3M &= 0xf0;          //Í£Ö¹¼ÆÊý, ¶¨Ê±Ä£Ê½, 12TÄ£Ê½, ²»Êä³öÊ±ÖÓ
 158   2                      IE2  &= ~(1<<5);        //½ûÖ¹ÖÐ¶Ï
 159   2                      if(TIMx->TIM_Interrupt == ENABLE)                       IE2  |=  (1<<5);        //ÔÊÐíÖÐ¶Ï
 160   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)         T4T3M |=  (1<<1);       //1T
 161   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)        T4T3M |=  (3<<1);       //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 162   2                      if(TIMx->TIM_ClkOut == ENABLE)  T4T3M |=  1;    //Êä³öÊ±ÖÓ
 163   2      
 164   2                      TH3 = (u8)(TIMx->TIM_Value >> 8);
 165   2                      TL3 = (u8)TIMx->TIM_Value;
 166   2                      if(TIMx->TIM_Run == ENABLE)     T4T3M |=  (1<<3);       //¿ªÊ¼ÔËÐÐ
 167   2                      return  0;              //³É¹¦
 168   2              }
 169   1      
 170   1              if(TIM == Timer4)               //Timer4,¹Ì¶¨Îª16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÎÞÓÅÏÈ¼¶
 171   1              {
 172   2                      if(TIMx->TIM_ClkSource >  TIM_CLOCK_Ext)        return 2;
 173   2                      T4T3M &= 0x0f;          //Í£Ö¹¼ÆÊý, ¶¨Ê±Ä£Ê½, 12TÄ£Ê½, ²»Êä³öÊ±ÖÓ
 174   2                      IE2  &= ~(1<<6);        //½ûÖ¹ÖÐ¶Ï
 175   2                      if(TIMx->TIM_Interrupt == ENABLE)                       IE2  |=  (1<<6);        //ÔÊÐíÖÐ¶Ï
 176   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)         T4T3M |=  (1<<5);       //1T
 177   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)        T4T3M |=  (3<<5);       //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
C51 COMPILER V9.54   TIMER                                                                 07/13/2021 16:39:39 PAGE 4   

 178   2                      if(TIMx->TIM_ClkOut == ENABLE)  T4T3M |=  (1<<4);       //Êä³öÊ±ÖÓ
 179   2      
 180   2                      TH4 = (u8)(TIMx->TIM_Value >> 8);
 181   2                      TL4 = (u8)TIMx->TIM_Value;
 182   2                      if(TIMx->TIM_Run == ENABLE)     T4T3M |=  (1<<7);       //¿ªÊ¼ÔËÐÐ
 183   2                      return  0;              //³É¹¦
 184   2              }
 185   1      
 186   1              return 2;       //´íÎó
 187   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    755    ----
   CONSTANT SIZE    =      2    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
